# Non-Abelian Double Braid with Error Injection & Correction


import numpy as np

import matplotlib.pyplot as plt


np.random.seed(42)

L = 32

phase = np.random.uniform(0, 2 * np.pi, (L, L))

memory = np.zeros((L, L))

braid_sites = [(6,6), (6,25), (25,6), (25,25)] # corners


def braid(phase, memory, order, chirality=1.0, steps=25, noise_amp=0.0):

for step in range(steps):

for idx, site in enumerate(order):

i, j = braid_sites[site]

dphi = chirality * 0.15 * (-1 if idx%2==0 else 1)

phase[i, :] += dphi

phase[:, j] -= dphi

# MBT memory update: "remembers" local phase info, heals errors

memory += np.cos(phase) * 0.12

memory *= 0.98 # gentle forgetting/healing

if noise_amp > 0:

memory += np.random.normal(0, noise_amp, memory.shape) # Inject errors

return phase, memory


# Run A then B (errors after A)

phase_A, mem_A = phase.copy(), memory.copy()

phase_A, mem_A = braid(phase_A, mem_A, [0,1], chirality=1.1, steps=20)

# Inject errors at midpoint

err_idx = np.random.choice(L*L, size=30, replace=False)

mem_A.ravel()[err_idx] += np.random.normal(0, 1.2, size=30)

phase_A, mem_A = braid(phase_A, mem_A, [2,3], chirality=1.1, steps=20)


# Run B then A (errors after B)

phase_B, mem_B = phase.copy(), memory.copy()

phase_B, mem_B = braid(phase_B, mem_B, [2,3], chirality=1.1, steps=20)

# Inject errors at midpoint

mem_B.ravel()[err_idx] += np.random.normal(0, 1.2, size=30)

phase_B, mem_B = braid(phase_B, mem_B, [0,1], chirality=1.1, steps=20)


# Memory values for logic states

memval_A = np.tanh(mem_A.mean())

memval_B = np.tanh(mem_B.mean())

difference = memval_B - memval_A


# Plot

fig, axs = plt.subplots(1, 3, figsize=(13, 4))

axs[0].imshow(np.cos(phase_A), cmap='twilight', vmin=-1, vmax=1)

axs[0].set_title(f"Final MBT Phase Field (A→B)\nMemory: {memval_A:.3f}")

axs[1].imshow(np.cos(phase_B), cmap='twilight', vmin=-1, vmax=1)

axs[1].set_title(f"Final MBT Phase Field (B→A)\nMemory: {memval_B:.3f}")

axs[2].bar(['A then B', 'B then A'], [memval_A, memval_B], color=['c', 'm'])

axs[2].set_ylabel("MBT Memory (logic state)")

axs[2].set_title(f"Difference: {difference:.3f}\n(non-Abelian logic, noisy)")

plt.tight_layout()

plt.show()


print(f"Memory after A then B (noisy): {memval_A:.4f}")

print(f"Memory after B then A (noisy): {memval_B:.4f}")

print(f"Difference (robust logic): {difference:.4e}")
