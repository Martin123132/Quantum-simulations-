import numpy as np

import matplotlib.pyplot as plt


# Parameters

N = 32

timesteps = 150

temperature = 0.4

pair_strength = 2.0 # This is our MBT analogue of pairing force


# Initialize phase field and 'pair field' (each cell tries to pair with a neighbor)

phase = np.random.uniform(-np.pi, np.pi, (N, N))

pair_field = np.zeros((N, N))


order_list = []


for t in range(timesteps):

# Choose neighbor direction for pairing (up/down/left/right)

neighbors = [np.roll(phase, 1, axis=0), np.roll(phase, -1, axis=0),

np.roll(phase, 1, axis=1), np.roll(phase, -1, axis=1)]

neighbor_avg = np.mean(neighbors, axis=0)


# MBT phase update: pair interaction plus noise

dphase = pair_strength * np.sin(neighbor_avg - phase) + temperature * np.random.randn(N, N) * 0.1

phase = (phase + dphase) % (2 * np.pi)


# Calculate local pair 'order' (how much each cell matches its neighbor)

pair_field = np.cos(phase - neighbor_avg)


# Global order parameter (how phase-locked the whole field is)

order_list.append(np.abs(np.mean(np.exp(1j*phase))))


# Plot final results

fig, axs = plt.subplots(1, 3, figsize=(15, 4))


axs[0].imshow(np.cos(phase), cmap="twilight", interpolation="nearest")

axs[0].set_title("Final MBT Phase Field (cos)")

axs[1].imshow(pair_field, cmap="inferno", interpolation="nearest")

axs[1].set_title("Final Pair Field (MBT Cooper Pairs)")

axs[2].plot(order_list, label="Pairing Order (MBT Cooper Pairs)")

axs[2].set_title("Global Pairing Order (Emergence)")

axs[2].set_xlabel("Timestep")

axs[2].legend()

plt.tight_layout()

plt.show()
